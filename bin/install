#!/usr/bin/env bash

print_usage() {
  local program="$1"
  local version="$2"
  local author="$3"

  cat <<-EOF
	$program $version

	Arch Linux with ZFS installer.

	USAGE:
	    $program [FLAGS] [OPTIONS] <DISK> <NETIF>

	FLAGS:
	    -e, --encrypt     Encrypts the partition for the zpool
	                      (default: no)
	    -h, --help        Prints help information
	    -I, --hibernation Enables hibernation/resume (WARNING: experimental!)
	                      (default: no)
	    -S, --suffix      Appends a unique suffix to zpool names
	    -V, --version     Prints version information
	    -W, --no-swap     Do not include a swap partition
	                      (default: create swap)

	OPTIONS:
	    -b, --boot-part=<PART>      Choose a boot partition for type partition
	                                (ex: nvme0n1p3)
	    -E, --encrypt-pass=<FILE>   Read the root pool password from file
	                                (default: prompt)
	    -l, --legacy-part=<PART>    Choose a legacy BIOS boot partition for
	                                type partition (ex: nvme0n1p5)
	    -p, --partition=<TYPE>      Choose a partitioning type (default: whole)
	                                (values: existing, remaining, whole)
	    -P, --root-pass=<FILE>      Read initial root password from file
	                                (default: prompt)
	    -r, --root-part=<PART>      Choose a root partition for type partition
	                                (ex: nvme0n1p4)
	    -s, --swap-part=<PART>      Choose a swap partition for type partition
	                                (ex: nvme0n1p2)
	    -t, --timezone=<TZ>         Timezone (ex: \`America/Edmonton')
	                                (default: \`UTC')
	        --bpool-size=<SIZE>     Size for boot pool partition, using sgdisk
	                                sizes (default: 4G)
	        --esp-size=<SIZE>       Size for ESP partition if using whole
	                                partitioning type, using sgdisk sizes
	                                (default: 4G)
	        --rpool-size=<SIZE>     Size for root pool partition, using sgdisk
	                                sizes (default: empty, uses all remaining)
	        --swap-size=<SIZE>      Size for swap partition if enabled, using
	                                sgdisk sizes (default: size of RAM)

	ARGS:
	    <DISK>      The disk to use for installation (ex: \`nvme0n1')
	                This can be found by using the \`lsblk' program.
	    <NETIF>     The network interface to setup for DHCP (ex: \`ens33')
	                This can be found by using the \`ip addr' program.

	EXAMPLES:
	    Example 1 Installing with default behavior
	      The following command installs Arch Linux using the whole disk,
	      with a swap partition, without encryption, and a timezone of
	      \`UTC'.

	      # $program nvme0n1 ens33

	    Example 2
	      The following command installs Arch Linux using the whole disk,
	      without a swap partition, with root pool encryption, and a
              timezone of Mountain time in North America.

	      # $program --encrypt --no-swap -timezone=America/Edmonton \\
	        nvme0n1 ens33

	    Example 3
	      The following command installs Arch Linux using the remaining space
	      on the disk, with a swap partition, without encryption, and a
	      timezone of \`UTC'.

	      # $program --partition=remaining nvme0n1 ens33

	AUTHOR:
	    $author
	EOF
}

main() {
  set -euo pipefail
  if [[ -n "${DEBUG:-}" ]]; then set -x; fi
  if [[ -n "${TRACE:-}" ]]; then set -xv; fi

  # shellcheck source=vendor/lib/libsh.full.sh
  . "${0%/*}/../vendor/lib/libsh.full.sh"
  # shellcheck source=lib/common.sh
  . "${0%/*}/../lib/common.sh"

  setup_traps trap_cleanup_files

  local program version author
  program="$(basename "$0")"
  version="0.1.0"
  author="Fletcher Nichol <fnichol@nichol.ca>"

  local arch override_repo repo_path_prefix repo_path base_path
  # The current system architecture
  arch="$(uname -m)"
  # The name of the override repo
  override_repo="override"
  # The parent path of all local repos
  repo_path_prefix=/var/local/pacman
  # The parent path of the override repo
  repo_path="$repo_path_prefix/$override_repo/$arch"
  # The root directory where the source code lives
  base_path="$(dirname "$0")/.."

  # Parse CLI arguments and set local variables
  parse_cli_args "$program" "$version" "$author" "$@"
  local inst_id="$INST_ID"
  local disk_name="$DISK"
  local boot_pool="$BOOT_POOL"
  local root_pool="$ROOT_POOL"
  local part_type="$PART_TYPE"
  local exist_boot_part="${BOOT_PARTITION:-}"
  local exist_root_part="${ROOT_PARTITION:-}"
  local exist_swap_part="${SWAP_PARTITION:-}"
  local exist_legacy_boot_part="${LEGACY_BOOT_PARTITION:-}"
  local tz="$TZ"
  local encrypt="$ENCRYPT"
  local swap="$SWAP"
  local hibernate="$HIBERNATE"
  local boot_pool_passwd="${BOOT_POOL_PASSWD:-}"
  local root_passwd="$ROOT_PASSWD"
  local boot_pool_size="$BPOOL_SIZE"
  local esp_size="$ESP_SIZE"
  local root_pool_size="$RPOOL_SIZE"
  local swap_size="$SWAP_SIZE"
  unset INST_ID DISK BOOT_POOL ROOT_POOL PART_TYPE BOOT_PARTITION \
    ROOT_PARTITION SWAP_PARTITION TZ ENCRYPT SWAP HIBERNATE BOOT_POOL_PASSWD \
    ROOT_PASSWD BPOOL_SIZE ESP_SIZE RPOOL_SIZE SWAP_SIZE

  need_cmd arch-chroot
  need_cmd awk
  need_cmd basename
  need_cmd blkid
  need_cmd cat
  need_cmd chmod
  need_cmd cp
  need_cmd curl
  need_cmd cut
  need_cmd dd
  need_cmd dirname
  need_cmd find
  need_cmd genfstab
  need_cmd grep
  need_cmd mkdir
  need_cmd mkfs.fat
  need_cmd modprobe
  need_cmd mount
  need_cmd pacman
  need_cmd pacman-key
  need_cmd readlink
  need_cmd rm
  need_cmd sed
  need_cmd sgdisk
  need_cmd sort
  need_cmd tail
  need_cmd tr
  need_cmd udevadm
  need_cmd umount
  need_cmd uname
  need_cmd vmstat
  need_cmd xargs
  need_cmd zfs
  need_cmd zpool

  # Find the persistent named disk device
  find_dev "$disk_name"
  local disk_dev="$FIND_DEV"
  unset FIND_DEV

  # Partition disk and determine partition devices
  partition_disk "$part_type" "$disk_dev" "$swap" \
    "$esp_size" "$boot_pool_size" "$root_pool_size" "$swap_size" \
    "$exist_boot_part" "$exist_root_part" "$exist_swap_part" \
    "$exist_legacy_boot_part"
  local esp_dev="$ESP_DEV"
  local boot_pool_dev="$BOOT_POOL_DEV"
  local root_pool_dev="$ROOT_POOL_DEV"
  local swap_dev="${SWAP_DEV:-}"
  local legacy_boot_dev="$LEGACY_BOOT_DEV"
  unset ESP_DEV BOOT_POOL_DEV ROOT_POOL_DEV SWAP_DEV LEGACY_BOOT_DEV

  # Format partitions, create ZFS zpools, and prepare the pools
  load_zfs
  setup_encryption_keys "$encrypt" "$root_pool" "$boot_pool" \
    "$swap" "$hibernate"
  local tmp_root_pool_key="${TMP_ROOT_POOL_KEY:-}"
  local tmp_boot_pool_key="${TMP_BOOT_POOL_KEY:-}"
  local tmp_swap_key="${TMP_SWAP_KEY:-}"
  unset TMP_ROOT_POOL_KEY TMP_BOOT_POOL_KEY TMP_SWAP_KEY
  format_esp "$part_type" "$esp_dev"
  create_boot_zpool "$boot_pool" "$boot_pool_dev" \
    "$encrypt" "$boot_pool_passwd" "$tmp_boot_pool_key" "$disk_name"
  local boot_pool_mapper_name="${BOOT_POOL_MAPPER_NAME:-}"
  unset BOOT_POOL_MAPPER_NAME
  create_root_zpool "$root_pool" "$root_pool_dev"
  create_root_datasets "$root_pool/$inst_id" "$encrypt" "$tmp_root_pool_key"
  create_boot_datasets "$boot_pool/$inst_id"
  prepare_pools "$boot_pool" "$root_pool" "$inst_id"
  mount_pools_for_install "$esp_dev" "$boot_pool" "$root_pool" "$inst_id" \
    "$encrypt" "$tmp_root_pool_key"

  # Install base system
  add_bootstrap_repo_keys
  add_bootstrap_override_repo \
    "$base_path" "$override_repo" "$repo_path_prefix" "$repo_path"
  install_base "$base_path" "$override_repo" "$repo_path_prefix" "$repo_path"
  install_hardware_specific_pkgs
  ignore_kernel_updates "$base_path"
  setup_zpool_cache "$root_pool"
  install_encryption_keys "$encrypt" "$tmp_boot_pool_key" "$tmp_root_pool_key" \
    "$swap" "$hibernate" "$tmp_swap_key"

  # Swap
  encrypt_swap "$swap" "$swap_dev" "$encrypt" "$hibernate" \
    "$disk_dev" "$disk_name" "$tmp_swap_key"
  local swap_mapper_name="${SWAP_MAPPER_NAME:-}"
  unset SWAP_MAPPER_NAME
  format_swap "$swap" "$hibernate" "$swap_dev" "$encrypt" "$swap_mapper_name"

  # Initially configure base system
  set_root_passwd "$root_passwd"
  set_timezone "$tz"
  setup_clock
  generate_locales
  enable_services "$boot_pool" "$encrypt" "$base_path"
  find_fastest_mirrors
  generate_hostid

  # Prepare user creation script for `root`
  copy_create_user_script "$base_path" "$version" \
    "$root_pool/$inst_id/DATA/default"

  # Prepare bootloader
  gen_fstab "$esp_dev" "$boot_pool" "$swap" "$swap_dev" \
    "$encrypt" "$swap_mapper_name"
  install_grub "$disk_dev" "$inst_id" \
    "$swap_dev" "$encrypt" "$tmp_swap_key" "$swap_mapper_name" "$hibernate"
  configure_mkinitcpio "$swap" "$encrypt" "$hibernate"

  # Finalize pools and end installer
  snapshot_datasets "$boot_pool/$inst_id" "$root_pool/$inst_id"
  create_install_be_unit
  finalize_pools "$boot_pool" "$root_pool" "$inst_id" \
    "$swap" "$swap_dev" "$encrypt" "$hibernate" \
    "$boot_pool_mapper_name" "$swap_mapper_name"
  finish
}

parse_cli_args() {
  local program version author
  program="$1"
  shift
  version="$1"
  shift
  author="$1"
  shift

  # Identifier for the installation of this operating system
  INST_ID="arch"
  # The name of the boot zpool
  BOOT_POOL="bpool"
  # The name of the root zpool
  ROOT_POOL="rpool"
  # Default partition type to whole
  PART_TYPE="whole"
  # Default timezone to UTC
  TZ="UTC"
  # Default to not encrypt the root pool
  ENCRYPT=""
  # Default to have a swap partition
  SWAP="true"
  # Default to not support hibernation
  HIBERNATE=""
  # Default to not use a unique suffix on zpools
  SUFFIX=""

  # Default boot pool partition size
  BPOOL_SIZE="4G"
  # Default ESP partition size if using whole partitioning
  ESP_SIZE="4G"
  # Default root pool partition size
  RPOOL_SIZE=""
  # Default swap partition size if swap is enabled. The default corresponds to
  # the amount of RAM present at install time, plus a small additional buffer
  # as a margin of error
  SWAP_SIZE="$(($(
    vmstat -s -S M \
      | grep 'total memory$' \
      | awk '{ print $1 }'
  ) + 64))M"

  OPTIND=1
  # Parse command line flags and options
  while getopts ":b:eE:Il:p:P:r:s:St:VWh-:" opt; do
    case $opt in
      b)
        BOOT_PARTITION="$OPTARG"
        ;;
      e)
        ENCRYPT=true
        ;;
      E)
        if [[ ! -f "$OPTARG" ]]; then
          print_usage "$program" "$version" "$author" >&2
          die "pool encrypt password file does not exist: $OPTARG"
        fi
        BOOT_POOL_PASSWD="$(cat "$OPTARG")"
        ;;
      h)
        print_usage "$program" "$version" "$author"
        exit 0
        ;;
      I)
        HIBERNATE=true
        ;;
      l)
        LEGACY_BOOT_PARTITION="$OPTARG"
        ;;
      p)
        case "$OPTARG" in
          existing | remaining | whole)
            # skip
            ;;
          *)
            print_usage "$program" "$version" "$author" >&2
            die "invalid partition type: $OPTARG"
            ;;
        esac
        PART_TYPE="$OPTARG"
        ;;
      P)
        if [[ ! -f "$OPTARG" ]]; then
          print_usage "$program" "$version" "$author" >&2
          die "password file does not exist: $OPTARG"
        fi
        ROOT_PASSWD="$(cat "$OPTARG")"
        ;;
      r)
        ROOT_PARTITION="$OPTARG"
        ;;
      s)
        SWAP_PARTITION="$OPTARG"
        ;;
      S)
        SUFFIX=true
        ;;
      t)
        TZ="$OPTARG"
        ;;
      V)
        print_version "$program" "$version"
        exit 0
        ;;
      W)
        SWAP=""
        ;;
      -)
        long_optarg="${OPTARG#*=}"
        case "$OPTARG" in
          boot-part=?*)
            BOOT_PARTITION="$long_optarg"
            ;;
          boot-part*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          bpool-size=?*)
            BPOOL_SIZE="$long_optarg"
            ;;
          bpool-size*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          encrypt)
            ENCRYPT=true
            ;;
          encrypt-pass=?*)
            if [[ ! -f "$OPTARG" ]]; then
              print_usage "$program" "$version" "$author" >&2
              die "pool encrypt password file does not exist: $OPTARG"
            fi
            BOOT_POOL_PASSWD="$(cat "$long_optarg")"
            ;;
          encrypt-pass*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          esp-size=?*)
            ESP_SIZE="$long_optarg"
            ;;
          esp-size*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          help)
            print_usage "$program" "$version" "$author"
            exit 0
            ;;
          hibernation)
            HIBERNATE=true
            ;;
          legacy-part=?*)
            LEGACY_BOOT_PARTITION="$long_optarg"
            ;;
          legacy-part*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          no-swap)
            SWAP=""
            ;;
          partition=?*)
            case "$long_optarg" in
              existing | remaining | whole)
                # skip
                ;;
              *)
                print_usage "$program" "$version" "$author" >&2
                die "invalid partition type: $long_optarg"
                ;;
            esac
            PART_TYPE="$long_optarg"
            ;;
          partition*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          root-part=?*)
            ROOT_PARTITION="$long_optarg"
            ;;
          root-part*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          root-pass=?*)
            if [[ ! -f "$OPTARG" ]]; then
              print_usage "$program" "$version" "$author" >&2
              die "password file does not exist: $OPTARG"
            fi
            ROOT_PASSWD="$(cat "$long_optarg")"
            ;;
          root-pass*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          rpool-size=?*)
            RPOOL_SIZE="$long_optarg"
            ;;
          rpool-size*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          suffix)
            SUFFIX=true
            ;;
          swap)
            SWAP=true
            ;;
          swap-part=?*)
            SWAP_PARTITION="$long_optarg"
            ;;
          swap-part*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          swap-size=?*)
            SWAP_SIZE="$long_optarg"
            ;;
          swap-size*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          timezone=?*)
            TZ="$long_optarg"
            ;;
          timezone*)
            print_usage "$program" "$version" "$author" >&2
            die "missing required argument for --$OPTARG option"
            ;;
          version)
            print_version "$program" "$version" "true"
            exit 0
            ;;
          '')
            # "--" terminates argument processing
            break
            ;;
          *)
            print_usage "$program" "$version" "$author" >&2
            die "invalid argument --$OPTARG"
            ;;
        esac
        ;;
      \?)
        print_usage "$program" "$version" "$author" >&2
        die "invalid option: -$OPTARG"
        ;;
    esac
  done
  shift "$((OPTIND - 1))"

  if [[ -z "${1:-}" ]]; then
    print_usage >&2
    die "required argument: <DISK>"
  fi
  DISK="$1"
  shift

  if [[ -z "${1:-}" ]]; then
    print_usage >&2
    die "required argument: <NETIF>"
  fi
  NETIF="$1"
  shift

  if [[ "$PART_TYPE" == "existing" && -z "${BOOT_PARTITION:-}" ]]; then
    print_usage "$program" "$version" "$author" >&2
    die "Boot partition (-b) required when partition type is 'existing'"
  fi
  if [[ "$PART_TYPE" == "existing" && -z "${ROOT_PARTITION:-}" ]]; then
    print_usage "$program" "$version" "$author" >&2
    die "Root partition (-r) required when partition type is 'existing'"
  fi
  if [[ "$PART_TYPE" == "existing" && -n "$SWAP" && -z "${SWAP_PARTITION:-}" ]]; then
    print_usage "$program" "$version" "$author" >&2
    die "Swap partition (-S) required when partition type is 'existing'"
  fi
  if [[ "$PART_TYPE" == "existing" && -z "${LEGACY_BOOT_PARTITION:-}" ]]; then
    print_usage "$program" "$version" "$author" >&2
    die "Legacy boot partition (-l) required when partition type is 'existing'"
  fi
  if [[ -n "$HIBERNATE" && -z "$SWAP" ]]; then
    print_usage "$program" "$version" "$author" >&2
    die "Swap must be enabled to fully support hibernation/resume"
  fi

  if [[ -n "$SUFFIX" ]]; then
    local suffix
    suffix="$(
      dd if=/dev/urandom bs=1 count=100 2>/dev/null \
        | tr -dc 'a-z0-9' \
        | cut -c-6
    )"
    BOOT_POOL="${BOOT_POOL}_$suffix"
    ROOT_POOL="${ROOT_POOL}_$suffix"
  fi

  if [[ -n "${ENCRYPT:-}" ]]; then
    if [[ -z "${BOOT_POOL_PASSWD:-}" ]]; then
      read_passwd "$BOOT_POOL encryption"
      BOOT_POOL_PASSWD="$PASSWD"
      unset PASSWD
    fi
  fi

  if [[ -z "${ROOT_PASSWD:-}" ]]; then
    read_passwd "root"
    ROOT_PASSWD="$PASSWD"
    unset PASSWD
  fi
}

in_chroot() {
  if [[ -n "${1:-}" ]]; then
    arch-chroot /mnt /bin/bash -c "$@"
  else
    arch-chroot /mnt /bin/bash
  fi
}

load_zfs() {
  section "Loading the ZFS kernel module"
  modprobe zfs
}

# Generates encryption keys for the root and boot pools.
#
# # Side Effects
#
# This function set up the following global variables:
#
# * `TMP_ROOT_POOL_KEY`: location of the the root pool key, stored temporarily
# * `TMP_BOOT_POOL_KEY`: location of the the boot pool key, stored temporarily
#
# If a swap partition was enabled with hibernation, then the following global
# variables are also set:
#
# * `TMP_SWAP_KEY`: location of the the swap key, stored temporarily, if swap
#   is enabled
setup_encryption_keys() {
  local encrypt="$1"

  if [[ -z "$encrypt" ]]; then
    return 0
  fi

  local root_pool="$2"
  local boot_pool="$3"
  local swap="$4"
  local hibernate="$5"

  TMP_ROOT_POOL_KEY="/tmp/etc/cryptkey.d/$root_pool-key-zfs"
  TMP_BOOT_POOL_KEY="/tmp/etc/cryptkey.d/$boot_pool-key-luks"

  section "Creating encryption keys"

  mkdir -p /tmp/etc/cryptkey.d
  chmod 0700 /tmp/etc/cryptkey.d
  info "Generating root pool key '$TMP_ROOT_POOL_KEY'"
  dd bs=32 count=1 if=/dev/urandom of="$TMP_ROOT_POOL_KEY"
  info "Generating boot pool key '$TMP_BOOT_POOL_KEY'"
  dd bs=32 count=1 if=/dev/urandom of="$TMP_BOOT_POOL_KEY"
  if [[ -n "$swap" && -n "$hibernate" ]]; then
    TMP_SWAP_KEY="/tmp/etc/cryptkey.d/swap-key-luks"
    info "Generating swap key '$TMP_SWAP_KEY'"
    dd bs=32 count=1 if=/dev/urandom of="$TMP_SWAP_KEY"
  fi
  chmod u=r,go= /tmp/etc/cryptkey.d/*
}

partition_disk() {
  local part_type="$1"
  shift
  local disk_dev="$1"
  shift
  local swap="$1"
  shift
  local esp_size="$1"
  shift
  local boot_pool_size="$1"
  shift
  local root_pool_size="$1"
  shift
  local swap_size="$1"
  shift

  case "$part_type" in
    existing)
      local boot_pool_dev="$1"
      local root_pool_dev="$2"
      local swap_dev="$3"
      local legacy_boot_dev="$4"

      partition_existing_disk "$disk_dev" "$swap" \
        "$boot_pool_dev" "$root_pool_dev" "$swap_dev" "$legacy_boot_dev"
      ;;
    remaining)
      partition_remaining_disk "$disk_dev" "$swap" \
        "$esp_size" "$boot_pool_size" "$root_pool_size" "$swap_size"
      ;;
    whole)
      partition_whole_disk "$disk_dev" "$swap" \
        "$esp_size" "$boot_pool_size" "$root_pool_size" "$swap_size"
      ;;
    *)
      die "Invalid partition type: $part_type"
      ;;
  esac
}

# Partitions an existing disk and sets variables for partition devices.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `ESP_DEV`: ESP partition device
# * `BOOT_POOL_DEV`: boot pool partition device
# * `ROOT_POOL_DEV`: root pool partition device
# * `LEGACY_BOOT_DEV`: legacy boot partition device
#
# If a swap partition was enabled, then the following global variables are also
# set:
#
# * `SWAP_DEV`: swap partition device
partition_existing_disk() {
  local disk_dev="$1"
  local swap="$2"
  local boot_pool_dev_name="$3"
  local root_pool_dev_name="$4"
  local swap_dev_name="$5"
  local legacy_boot_dev_name="$6"

  section "Partitioning using existing disk '$disk_dev'"

  find_esp_dev "$disk_dev"
  ESP_DEV="$FIND_ESP_DEV"
  unset FIND_ESP_DEV

  find_dev "$boot_pool_dev_name"
  BOOT_POOL_DEV="$FIND_DEV"
  unset FIND_DEV
  info "Using existing boot pool partition '$BOOT_POOL_DEV'"

  find_dev "$root_pool_dev_name"
  ROOT_POOL_DEV="$FIND_DEV"
  unset FIND_DEV
  info "Using existing root pool partition '$ROOT_POOL_DEV'"

  if [[ -n "$swap" ]]; then
    find_dev "$swap_dev_name"
    SWAP_DEV="$FIND_DEV"
    unset FIND_DEV
    info "Using existing swap partition '$SWAP_DEV'"
  fi

  find_dev "$legacy_boot_dev_name"
  LEGACY_BOOT_DEV="$FIND_DEV"
  unset FIND_DEV
  info "Using existing legacy BIOS pool partition '$LEGACY_BOOT_DEV'"
}

# Partitions remaining space on an existing disk and sets variables for
# partition devices.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `ESP_DEV`: ESP partition device
# * `BOOT_POOL_DEV`: boot pool partition device
# * `ROOT_POOL_DEV`: root pool partition device
# * `LEGACY_BOOT_DEV`: legacy boot partition device
#
# If a swap partition was enabled, then the following global variables are also
# set:
#
# * `SWAP_DEV`: swap partition device
partition_remaining_disk() {
  local disk_dev="$1"
  local swap="$2"
  local esp_size="$3"
  local boot_pool_size="$4"
  local root_pool_size="$5"
  local swap_size="$6"

  section "Partitioning using remaining space on disk '$disk_dev'"

  find_esp_dev "$disk_dev"
  ESP_DEV="$FIND_ESP_DEV"
  unset FIND_ESP_DEV

  local part boot_pool_part root_pool_part
  part="$(sgdisk --print "$disk_dev" | tail -n 1 | awk '{ print $1 }')"
  part=$((part + 1))
  boot_pool_part="$part"
  part=$((part + 1))
  root_pool_part="$part"
  part=$((part + 1))
  if [[ -n "$swap" ]]; then
    local swap_part="$part"
  fi
  part=$((part + 1))
  local legacy_boot_part="$part"

  partition_boot_pool "$disk_dev" "$boot_pool_part" "$boot_pool_size"
  partition_root_pool "$disk_dev" "$root_pool_part" "$root_pool_size"
  if [[ -n "$swap" ]]; then
    partition_swap "$disk_dev" "$swap_part" "$swap_size"
  fi
  partition_legacy_boot "$disk_dev" "$legacy_boot_part"
}

# Partitions entire disk and sets variables for partition devices.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `ESP_DEV`: ESP partition device
# * `BOOT_POOL_DEV`: boot pool partition device
# * `ROOT_POOL_DEV`: root pool partition device
# * `LEGACY_BOOT_DEV`: legacy boot partition device
#
# If a swap partition was enabled, then the following global variables are also
# set:
#
# * `SWAP_DEV`: swap partition device
partition_whole_disk() {
  local disk_dev="$1"
  local swap="$2"
  local esp_size="$3"
  local boot_pool_size="$4"
  local root_pool_size="$5"
  local swap_size="$6"

  local part=0
  part=$((part + 1))
  local esp_part="$part"
  part=$((part + 1))
  local boot_pool_part="$part"
  part=$((part + 1))
  local root_pool_part="$part"
  part=$((part + 1))
  if [[ -n "$swap" ]]; then
    local swap_part="$part"
  fi
  part=$((part + 1))
  local legacy_boot_part="$part"

  section "Partitioning using the whole disk '$disk_dev'"

  info "Clearing partition table on '$disk_dev'"
  sgdisk --zap-all "$disk_dev"

  partition_esp "$disk_dev" "$esp_part" "$esp_size"
  partition_boot_pool "$disk_dev" "$boot_pool_part" "$boot_pool_size"
  if [[ -n "$swap" ]]; then
    partition_swap "$disk_dev" "$swap_part" "$swap_size"
  fi
  partition_root_pool "$disk_dev" "$root_pool_part" "$root_pool_size"
  partition_legacy_boot "$disk_dev" "$legacy_boot_part"
}

# Creates a partition for the ESP on a given disk and sets a global
# variable.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `ESP_DEV`: boot pool partition device
partition_esp() {
  local disk_dev="$1"
  local part="$2"
  local esp_size="$3"

  ESP_DEV="${disk_dev}-part${part}"
  info "Creating ESP partition for UEFI booting '$ESP_DEV' of size '$esp_size'"
  sgdisk \
    --new="$part:1M:+$esp_size" \
    --typecode="$part:EF00" \
    "$disk_dev"
  wait_on_part_dev "$ESP_DEV"
}

# Creates a partition for swap on a given disk and sets a global variable.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `SWAP_DEV`: swap partition device
partition_swap() {
  local disk_dev="$1"
  local part="$2"
  local swap_size="$3"

  SWAP_DEV="${disk_dev}-part${part}"
  info "Creating swap partition '$SWAP_DEV' of size '$swap_size'"
  sgdisk \
    --new="$part:0:+$swap_size" \
    --typecode="$part:8200" \
    "$disk_dev"
  wait_on_part_dev "$SWAP_DEV"
}

# Creates a partition for the boot pool on a given disk and sets a global
# variable.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `BOOT_POOL_DEV`: boot pool partition device
partition_boot_pool() {
  local disk_dev="$1"
  local part="$2"
  local boot_pool_size="$3"

  BOOT_POOL_DEV="${disk_dev}-part${part}"
  info "Creating boot pool partition '$BOOT_POOL_DEV' of size '$boot_pool_size'"
  sgdisk \
    --new="$part:0:+$boot_pool_size" \
    --typecode="$part:BE00" \
    "$disk_dev"
  wait_on_part_dev "$BOOT_POOL_DEV"
}

# Creates a partition for the root pool on a given disk and sets a global
# variable.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `ROOT_POOL_DEV`: root pool partition device
partition_root_pool() {
  local disk_dev="$1"
  local part="$2"
  local root_pool_size="$3"

  ROOT_POOL_DEV="${disk_dev}-part${part}"
  info "Creating root pool partition '$ROOT_POOL_DEV' of size '${3:-*}'"
  local sgdisk_size
  if [[ -z "$root_pool_size" ]]; then
    sgdisk_size="0"
  else
    sgdisk_size="+$root_pool_size"
  fi
  sgdisk \
    --new="$part:0:$sgdisk_size" \
    --typecode="$part:BF00" \
    "$disk_dev"
  wait_on_part_dev "$ROOT_POOL_DEV"
}

# Creates a partition for legacy BIOS booting on a given disk and sets a global
# variable.
#
# # Side Effects
#
# This function sets the following global variables:
#
# * `LEGACY_BOOT_DEV`: legacy BIOS boot partition device
partition_legacy_boot() {
  local disk_dev="$1"
  local part="$2"

  LEGACY_BOOT_DEV="${disk_dev}-part${part}"
  info "Creating legacy BIOS boot partition '$LEGACY_BOOT_DEV'"
  sgdisk \
    --set-alignment=1 \
    --new="$part:24k:+1000K" \
    --typecode="$part:EF02" \
    "$disk_dev"
  wait_on_part_dev "$BOOT_POOL_DEV"
}

# Finds the given device name under the `/dev/disk/by-id` tree and sets a
# global variable.
#
# # Side Effects
#
# This function sets the following global variable:
#
# * `FIND_DEV`: found device
find_dev() {
  local device_name="$1"
  local retries=0

  section "Resolving device by disk id for '/dev/$device_name'"

  udevadm trigger
  udevadm settle

  while [[ $retries -lt 5 ]]; do
    while read -r device_id; do
      if [[ "$(readlink -f "$device_id")" == "/dev/$device_name" ]]; then
        FIND_DEV="$device_id"
        info "Found device by ID for /dev/$device_name: $FIND_DEV"
        return
      fi
    done < <(find /dev/disk/by-id -not -type d | sort --ignore-case)

    retries=$((retries + 1))
    info "Partition ID not found, sleeping and retrying ($retries/5)"
    sleep 3
  done

  die "Could not find partition ID for /dev/$device_name"
}

# Finds the EFI System Partition (EFI) on a given disk device.
#
# # Side Effects
#
# This function sets the following global variable:
#
# * `FIND_ESP_DEV`: found ESP partition device
find_esp_dev() {
  local disk_dev="$1"
  local esp_dev

  esp_dev="$(sgdisk --print "$disk_dev" | awk '$6 == "EF00" { print $1 }')"
  if [[ -z "$esp_dev" ]]; then
    die "Cannot find EFI System Partition (ESP) on '$disk_dev'"
  fi

  FIND_ESP_DEV="${disk_dev}-part${esp_dev}"
  info "Found EFI System Partition (ESP) '$FIND_ESP_DEV'"
  wait_on_part_dev "$FIND_ESP_DEV"
}

wait_on_part_dev() {
  local part_dev="$1"
  local retries=0

  udevadm settle

  while [[ $retries -lt 5 ]]; do
    if [[ -e "$part_dev" ]]; then
      return
    fi

    retries=$((retries + 1))
    sleep 3
  done

  die "Could not find partition device '$part_dev'"
}

format_esp() {
  local part_type="$1"
  local esp_dev="$2"

  if [[ "$part_type" == "whole" ]]; then
    section "Formatting EFI System Partition (ESP) filesystem on '$esp_dev'"
    mkfs.vfat -n EFI "$esp_dev"
  fi
}

encrypt_swap() {
  local swap="$1"
  local swap_dev="$2"
  local encrypt="$3"
  local hibernate="$4"

  if [[ -n "$swap" && -n "$encrypt" ]]; then
    local disk_dev="$5"
    local disk_name="$6"

    local disk_guid partnum swap_mapper_name
    disk_guid="$(
      sgdisk --print "$disk_dev" \
        | grep '^Disk identifier' \
        | awk '{ print $NF }'
    )"
    partnum="$(echo "$swap_dev" | awk -F- '{ print $NF }')"
    swap_mapper_name="$disk_name-$disk_guid-$partnum-luks-swap"

    if [[ -n "$hibernate" ]]; then
      # Persistent swap needed for hibernation/resuming
      local tmp_swap_key="$7"
      section "Creating encrypted swap partition '$swap_dev'"
      cryptsetup luksFormat \
        --batch-mode \
        --type luks2 \
        --key-file "$tmp_swap_key" \
        "$swap_dev"

      info "Opening LUKS container '$swap_dev' as '$swap_mapper_name'"
      cryptsetup open "$swap_dev" "$swap_mapper_name" --key-file "$tmp_swap_key"
    else
      # Otherwise, a new encrypted swap with a random key will be re-created on
      # each boot
      section "Configuring an ephemeral encrypted swap on '$swap_mapper_name'"
      local opts
      opts="swap,cipher=aes-cbc-essiv:sha256,size=256,discard"
      echo "$swap_mapper_name $swap_dev /dev/urandom $opts" >>/mnt/etc/crypttab
    fi

    SWAP_MAPPER_NAME="$swap_mapper_name"
  fi
}

format_swap() {
  local swap="$1"
  local hibernate="$2"

  if [[ -z "$swap" || -n "$hibernate" ]]; then
    return
  fi

  local swap_dev="$3"
  local encrypt="$4"
  local swap_mapper_name="$5"

  local device
  if [[ -n "$encrypt" ]]; then
    device="/dev/mapper/$swap_mapper_name"
  else
    device="$swap_dev"
  fi

  section "Creating swap filesystem on '$device'"
  mkswap "$device"
}

# Creates the boot zpool.
#
# # Side Effects
#
# If a encyption was enabled, then the following global variable is set:
#
# * `BOOT_POOL_MAPPER_NAME`: encrypted boot pool partition mapper device
create_boot_zpool() {
  local boot_pool="$1"
  local boot_pool_dev="$2"
  local encrypt="$3"
  local boot_pool_passwd="$4"
  local tmp_boot_pool_key="$5"
  local disk_name="$6"
  local pool_dev

  section "Creating boot zpool"

  if [[ -n "$encrypt" ]]; then
    local disk_guid partnum boot_pool_mapper_name iters
    disk_guid="$(
      sgdisk --print "$disk_dev" \
        | grep '^Disk identifier' \
        | awk '{ print $NF }'
    )"
    partnum="$(echo "$boot_pool_dev" | awk -F- '{ print $NF }')"
    boot_pool_mapper_name="$disk_name-$disk_guid-$partnum-luks-$boot_pool"

    info "Formatting and encrypting a boot pool device '$boot_pool_mapper_name'"
    # Format the partition, use the password to set slot 0
    echo "$boot_pool_passwd" \
      | cryptsetup luksFormat \
        --batch-mode \
        --type luks1 \
        "$boot_pool_dev"

    # Determine the interations and lower this number to something like 5% to
    # make decrypting faster--warning this also makes brute force attacking of
    # this password 20x faster!
    iters="$(
      cryptsetup luksDump /dev/nvme0n1p2 \
        | grep Iterations: \
        | head -n 1 \
        | awk '{ print ($NF * 0.05) }'
    )"

    # Add the key file into slot 2, using the lower iterations value--this
    # leaves slot 1 open for an admin user password, yubi key, etc.
    echo "$boot_pool_passwd" \
      | cryptsetup luksAddKey \
        --pbkdf-force-iterations "$iters" \
        --key-slot 2 \
        "$boot_pool_dev" \
        "$tmp_boot_pool_key"

    # Remove the password in slot 0
    echo "$boot_pool_passwd" \
      | cryptsetup luksRemoveKey \
        "$boot_pool_dev"
    # Re-add the password into slot 0, but this time with the lower iterations
    # value
    echo "$boot_pool_passwd" \
      | cryptsetup luksAddKey \
        --pbkdf-force-iterations "$iters" \
        --key-file "$tmp_boot_pool_key" \
        "$boot_pool_dev"

    # Finally, open the encrypted mapper
    cryptsetup open \
      "$boot_pool_dev" \
      "$boot_pool_mapper_name" \
      --key-file "$tmp_boot_pool_key"

    local crypttab_key opts
    crypttab_key="/etc/cryptkey.d/$(basename "$tmp_boot_pool_key")"
    opts="luks,discard,key-slot=2"
    echo "$boot_pool_mapper_name $boot_pool_dev $crypttab_key $opts" \
      >>/tmp/etc/crypttab

    BOOT_POOL_MAPPER_NAME="$boot_pool_mapper_name"
    pool_dev="/dev/mapper/$boot_pool_mapper_name"
  else
    pool_dev="$boot_pool_dev"
  fi

  info "Creating the boot zpool '$boot_pool' on '$pool_dev'"
  # GRUB does not support all of the zpool features. See spa_feature_names in
  # grub-core/fs/zfs/zfs.c. This step creates a separate boot pool for /boot
  # with the features limited to only those that GRUB supports, allowing the
  # root pool to use any/all features. Note that GRUB opens the pool read-only,
  # so all read-only compatible features are "supported" by GRUB.
  #
  # References:
  # * https://openzfs.github.io/openzfs-docs/Getting%20Started/Arch%20Linux/Root%20on%20ZFS/2-system-installation.html
  # * https://github.com/openzfs/zfs/blob/master/cmd/zpool/compatibility.d/grub2
  # * http://git.savannah.gnu.org/cgit/grub.git/tree/grub-core/fs/zfs/zfs.c#n276
  # * https://github.com/zfsonlinux/zfs/wiki/Debian-Buster-Root-on-ZFS
  # * https://wiki.archlinux.org/index.php/ZFS#GRUB-compatible_pool_creation
  zpool create \
    -R /mnt \
    -o compatibility=grub2 \
    -o ashift=12 \
    -o autotrim=on \
    -O acltype=posixacl \
    -O canmount=off \
    -O compression=lz4 \
    -O devices=off \
    -O normalization=formD \
    -O relatime=on \
    -O xattr=sa \
    -O mountpoint=/boot \
    "$boot_pool" \
    "$pool_dev"

  if ! zpool list "$boot_pool" >/dev/null 2>&1; then
    die "Boot zpool '$boot_pool' failed to create, see error above"
  fi
}

create_root_zpool() {
  local root_pool="$1"
  local root_pool_dev="$2"

  section "Creating the root zpool '$root_pool' on '$root_pool_dev'"

  zpool create \
    -R /mnt \
    -o ashift=12 \
    -o autotrim=on \
    -O acltype=posixacl \
    -O canmount=off \
    -O compression=zstd \
    -O dnodesize=auto \
    -O normalization=formD \
    -O relatime=on \
    -O xattr=sa \
    -O mountpoint=/ \
    "$root_pool" \
    "$root_pool_dev"

  if ! zpool list "$root_pool" >/dev/null 2>&1; then
    die "Root zpool '$root_pool' failed to create, see error above"
  fi
}

create_boot_datasets() {
  local base="$1"

  section "Creating boot zpool datasets"

  info "Creating zfs dataset '$base'"
  zfs create -o canmount=off -o mountpoint=none "$base"

  if ! zfs list "$base" >/dev/null 2>&1; then
    die "ZFS dataset '$base' failed to create, see error above"
  fi

  info "Creating '$base' base system datasets"
  zfs create -o canmount=off -o mountpoint=none "$base/BOOT"
  zfs create -o canmount=noauto -o mountpoint=/boot "$base/BOOT/default"

  zfs mount "$base/BOOT/default"
}

create_root_datasets() {
  local base="$1"
  local encrypted="$2"

  section "Creating root zpool datasets"

  if [[ -n "$encrypted" ]]; then
    local tmp_root_pool_key="$3"

    info "Creating encrypted zfs dataset '$base'"
    zfs create \
      -o canmount=off \
      -o mountpoint=none \
      -o encryption=on \
      -o keyformat=raw \
      -o "keylocation=file://$tmp_root_pool_key" \
      "$base"
    # Set the permanent value for keylocation now that the data has been
    # created and encrypted
    zfs set \
      "keylocation=file:///etc/cryptkey.d/$(basename "$tmp_root_pool_key")" \
      "$base"

    if ! zfs list "$base" >/dev/null 2>&1; then
      die "ZFS dataset '$base' failed to create, is the password too short?"
    fi
  else
    info "Creating zfs dataset '$base'"
    zfs create -o canmount=off -o mountpoint=none "$base"

    if ! zfs list "$base" >/dev/null 2>&1; then
      die "ZFS dataset '$base' failed to create, see error above"
    fi
  fi

  info "Creating '$base' base system datasets"
  zfs create -o canmount=off -o mountpoint=none "$base/ROOT"
  # Data datasets would be omitted when performing an upgrade rollback
  zfs create -o canmount=off -o mountpoint=none "$base/DATA"

  zfs create -o canmount=noauto -o mountpoint=/ "$base/ROOT/default"
  zfs create -o canmount=off -o mountpoint=/ "$base/DATA/default"

  zfs mount "$base/ROOT/default"

  local d dataset

  for d in usr var var/lib var/lib/systemd; do
    dataset="$base/DATA/default/$d"
    info "Creating DATA dataset '$dataset'"
    zfs create -o canmount=off "$dataset"
  done

  for d in var/cache var/tmp; do
    dataset="$base/DATA/default/$d"
    info "Creating DATA dataset '$dataset'"
    zfs create -o com.sun:auto-snapshot=false "$dataset"
  done

  for d in \
    home srv usr/local var/log var/spool \
    opt var/cache/pacman var/log/journal var/lib/AccountService \
    var/lib/systemd/coredump \
    var/lib/docker var/lib/lxc var/lib/libvirt; do

    dataset="$base/DATA/default/$d"
    info "Creating DATA dataset '$dataset'"
    zfs create -o canmount=on "$dataset"
  done

  dataset="$base/DATA/default/home/root"
  info "Creating DATA dataset '$dataset'"
  zfs create -o canmount=on -o mountpoint=/root "$dataset"

  info "Setting permission on /var/tmp"
  chmod 1777 /mnt/var/tmp
  info "Setting permission on /root"
  chmod 750 /mnt/root
}

prepare_pools() {
  local boot_pool="$1"
  local root_pool="$2"
  local inst_id="$3"

  section "Preparing zpools"

  info "Unmounting all ZFS datasets"
  zfs unmount -a
  zfs unmount "$boot_pool/$inst_id/BOOT/default"
  zfs unmount "$root_pool/$inst_id/ROOT/default"

  info "Exporting the pools"
  zpool export "$boot_pool"
  zpool export "$root_pool"
}

mount_pools_for_install() {
  local esp_dev="$1"
  local boot_pool="$2"
  local root_pool="$3"
  local inst_id="$4"
  local encrypted="$5"

  section "Mounting zpools for system installation and configuration"

  info "Re-importing the pools"
  zpool import -N -d /dev/disk/by-id -R /mnt "$root_pool"
  zpool import -N -d /dev/disk/by-id -R /mnt "$boot_pool"

  if [[ -n "$encrypted" ]]; then
    local tmp_root_pool_key="$6"

    info "Decrypting root pool dataset '$root_pool/$inst_id'"
    zfs load-key -L "file://$tmp_root_pool_key" "$root_pool/$inst_id"
  fi

  info "Re-mounting datasets"
  zfs mount "$root_pool/$inst_id/ROOT/default"
  zfs mount "$boot_pool/$inst_id/BOOT/default"
  zfs mount -a

  info "Mounting the EFI System Partition (ESP) device $esp_dev"
  mkdir -pv /mnt/boot/efi
  mount "$esp_dev" /mnt/boot/efi
}

gen_fstab() {
  local esp_dev="$1"
  local boot_pool="$2"
  local swap="$3"

  section "Generating /etc/fstab"

  mkdir -pv /mnt/etc

  info "Using genfstab to generate system entries for boot pool '$boot_pool'"
  genfstab -U /mnt \
    | sed 's;zfs[[:space:]]*;zfs zfsutil,;g' \
    | grep 'zfs zfsutil' \
    | grep "^$boot_pool" \
      >>/mnt/etc/fstab

  local esp_uuid esp_mntops
  esp_uuid="$(blkid -s UUID -o value "$esp_dev")"

  esp_mntops="x-systemd.idle-timeout=1min,x-systemd.automount,noauto"
  esp_mntops="$esp_mntops,umask=0022,fmask=0022,dmask=0022"

  info "Adding entry for ESP (/boot) mount"
  echo "UUID=$esp_uuid /boot/efi vfat $esp_mntops 0 1" >>/mnt/etc/fstab

  if [[ -n "$swap" ]]; then
    local swap_dev="$3"
    local encrypt="$4"

    if [[ -n "$encrypt" ]]; then
      local swap_mapper_name="$5"

      info "Adding entry for encrypted swap"
      echo "/dev/mapper/$swap_mapper_name none swap defaults 0 0" \
        >>/mnt/etc/fstab
    else
      info "Adding entry for swap"
      echo "$swap_dev none swap defaults 0 0" >>/mnt/etc/fstab
    fi
  fi
}

add_bootstrap_repo_keys() {
  local gpg_key

  section "Downloading [archzfs] repository key"

  gpg_key="$(mktemp_file)"
  cleanup_file "$gpg_key"
  download "https://archzfs.com/archzfs.gpg" "$gpg_key"
  pacman-key -a "$gpg_key"

  info "Adding [archzfs] repository key to archiso"
  pacman-key --lsign-key DDF7DB817396A49B2A2723F7403BD972F75D9D76
}

add_bootstrap_override_repo() {
  local base_path="$1"
  local override_repo="$2"
  local repo_path_prefix="$3"
  local repo_path="$4"

  if has_local_override_repo "$override_repo"; then
    local local_repo_path
    local_repo_path="$(readlink -f "$base_path/$override_repo")"

    section "Detected [$override_repo] repository to use for bootstrapping"

    mkdir -pv "$repo_path"
    cp -rv "$local_repo_path"/*.pkg.tar.zst* "$repo_path"

    find "$repo_path" -name '*.pkg.tar.zst' -print0 \
      | xargs -0 repo-add "$repo_path/$override_repo.db.tar.xz"

    info "Adding [$override_repo] repository to /etc/pacman.conf"
    insert_into_pacman_conf \
      "$(override_repo_block "$override_repo" "$repo_path_prefix")" \
      /etc/pacman.conf

    pacman -Sy --noconfirm
  fi
}

install_base() {
  local base_path="$1"
  local override_repo="$2"
  local repo_path_prefix="$3"
  local repo_path="$4"

  local extra_pkgs=(
    zfs-linux zfs-utils
    linux-firmware intel-ucode amd-ucode grub efibootmgr os-prober
    dhcpcd openssh sudo pacman-contrib
    terminus-font
  )

  section "Installing base system"

  info "Bootstrapping base installation with pacstrap"
  pacstrap /mnt base

  add_override_repo \
    "$base_path" "$override_repo" "$repo_path_prefix" "$repo_path"
  add_archzfs_repo

  info "Refreshing package databases"
  in_chroot "pacman -Sy --noconfirm"

  install_kernel_pkg

  info "Installing extra base packages"
  in_chroot "pacman -Sy --noconfirm; pacman -S --noconfirm ${extra_pkgs[*]}"

  # The exit code of the previous failed pacman install with be `0` regardless
  # of whether the installation was successful. Any version mismatching of
  # ZFS-related packages and the current Linux kernel will result in a detected
  # "unable to satisfy dependency" which is considered a successful termination
  # of the program. Instead of relying on the exit code of the previous
  # command, we'll check if one of the packages has been installed and assume
  # that if it is not, then the entire set has failed and terminate the
  # program.
  if ! in_chroot "pacman -Qi zfs-linux" >/dev/null 2>&1; then
    die "Installation of zfs-linux failed, check kernel version support"
  fi

  install_be_pkgs

  info "Setting sudoers policy"
  in_chroot "echo '%wheel ALL=(ALL) ALL' > /etc/sudoers.d/01_wheel"

  info "Remove default .bashrc in /etc/skell"
  in_chroot "rm -f /etc/skel/.bashrc"
}

install_be_pkgs() {
  in_chroot "echo 'nobody ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/00_nobody"

  info "Installing Paru as AUR helper"
  in_chroot <<-EOF
	set -eu
	pacman -S --noconfirm --needed base-devel git
	git clone https://aur.archlinux.org/paru-bin.git /tmp/paru-bin
	chown -R nobody:nobody /tmp/paru-bin
	cd /tmp/paru-bin
	sudo -u nobody makepkg --syncdeps --install --noconfirm
	cd -
	rm -rf /tmp/paru-bin
	EOF
  info "Installing boot environment manager bieaz & pacman helper rozb3-pac"
  in_chroot <<-'EOF'
        export HOME=/tmp/build
	mkdir -p "$HOME"
	chown -R nobody:nobody "$HOME"
	sudo -u nobody env HOME=$HOME \
	  paru -S --noconfirm --clonedir $HOME bieaz rozb3-pac
	rm -rf "$HOME"
	EOF

  in_chroot "rm -f /etc/sudoers.d/00_nobody"
}

add_override_repo() {
  local base_path="$1"
  local override_repo="$2"
  local repo_path_prefix="$3"
  local repo_path="$4"

  local mounted_repo_path
  mounted_repo_path="/mnt$repo_path"

  info "Creating [$override_repo] repository root $mounted_repo_path"
  mkdir -pv "$mounted_repo_path"

  if has_local_override_repo "$override_repo"; then
    info "Copying local [$override_repo] repository packages to system"
    cp -rv "$base_path/$override_repo"/*.pkg.tar.xz* "$mounted_repo_path"
  fi

  info "Preparing [$override_repo] repository locally"
  in_chroot "find $repo_path -name '*.pkg.tar.xz' -print0 \
      | xargs -0 repo-add $repo_path/$override_repo.db.tar.xz"

  info "Adding [$override_repo] repository to /mnt/etc/pacman.conf"
  insert_into_pacman_conf \
    "$(override_repo_block "$override_repo" "$repo_path_prefix")" \
    /mnt/etc/pacman.conf
}

add_archzfs_repo() {
  info "Fetching latest archzfs repository mirrorlist"
  mkdir -pv /mnt/etc/pacman.d
  download "https://git.io/Jsfw2" /mnt/etc/pacman.d/mirrorlist-archzfs

  info "Adding [archzfs] repository to /mnt/etc/pacman.conf"
  insert_into_pacman_conf "$(archzfs_repo_block)" /mnt/etc/pacman.conf

  info "Adding [archzfs] repository key"
  in_chroot "pacman-key -r F75D9D76 && pacman-key --lsign-key F75D9D76"
}

install_kernel_pkg() {
  local compat_ver current_ver

  info "Determining kernel version compatible with zfs-linux"

  compat_ver="$(
    in_chroot "pacman -Si zfs-linux \
      | grep '^Depends On' \
      | sed 's,.*linux=,,' \
      | awk '{ print \$1 }'"
  )"
  current_ver="$(
    in_chroot "pacman -Si linux | grep ^Version | awk '{ print \$3 }'"
  )"

  if [[ "$compat_ver" = "$current_ver" ]]; then
    info "Installing current kernel version '$current_ver'"
    in_chroot "pacman -S --noconfirm linux linux-headers"
  else
    info "Installing zfs-linux compatible kernel version '$compat_ver'"
    local url=https://archive.archlinux.org/packages
    pacstrap -U /mnt \
      "$url/l/linux/linux-$compat_ver-x86_64.pkg.tar.zst" \
      "$url/l/linux-headers/linux-headers-$compat_ver-x86_64.pkg.tar.zst"
  fi
}

install_hardware_specific_pkgs() {
  section "Install hardware specific packages"

  if is_in_vmware; then
    info "Installing VMware-specific software"
    in_chroot "pacman -S --noconfirm open-vm-tools"
  fi
}

ignore_kernel_updates() {
  local base_path="$1"
  local pkgs=(
    linux
    linux-headers
    zfs-linux
    zfs-utils
  )

  section "Ignoring kernel and zfs package updates by default (use upgrade-kernel)"

  info "Installing /usr/bin/upgrade-kernel"
  cp -v -p "$base_path/lib/upgrade-kernel.sh" /mnt/usr/bin/upgrade-kernel

  info "Setting up pacman.conf to ignore kernel updates"
  sed -i -e 's/#IgnorePkg/IgnorePkg/' /mnt/etc/pacman.conf
  sed -i "/^IgnorePkg/ s/$/ ${pkgs[*]}/" /mnt/etc/pacman.conf
}

setup_zpool_cache() {
  local root_pool="$1"

  section "Setting up zpool cachefile"

  info "Clearing zpool cachefile property for root pool '$root_pool'"
  rm -fv /mnt/etc/zfs/zpool.cache
  in_chroot "zpool set cachefile=none '$root_pool'"

  mkdir -pv /mnt/etc/zfs
  if [[ -e /etc/zfs/zpool.cache ]]; then
    info "Copying zpool.cache"
    cp -v /etc/zfs/zpool.cache /mnt/etc/zfs/
  fi

  info "Setting zpool cachefile property for root pool '$root_pool'"
  in_chroot "zpool set cachefile=/etc/zfs/zpool.cache '$root_pool'"
}

install_encryption_keys() {
  local encrypt="$1"
  local tmp_boot_pool_key="$2"
  local tmp_root_pool_key="$3"
  local swap="$4"
  local hibernate="$5"

  if [[ -z "$encrypt" ]]; then
    return 0
  fi

  section "Installing encryption keys"

  mkdir -p /mnt/etc/cryptkey.d
  chmod 0700 /mnt/etc/cryptkey.d
  info "Installing boot pool key"
  mv -v \
    "$tmp_boot_pool_key" \
    "/mnt/etc/cryptkey.d/$(basename "$tmp_boot_pool_key")"
  info "Installing root pool key"
  mv -v \
    "$tmp_root_pool_key" \
    "/mnt/etc/cryptkey.d/$(basename "$tmp_root_pool_key")"
  if [[ -n "$swap" && -n "$hibernate" ]]; then
    local tmp_swap_key="$6"

    info "Installing swap key"
    mv -v \
      "$tmp_swap_key" \
      "/mnt/etc/cryptkey.d/$(basename "$tmp_swap_key")"
  fi
  chmod u=r,go= /mnt/etc/cryptkey.d/*

  mkdir -p /mnt/etc
  info "Installing /etc/crypttab"
  mv -v /tmp/etc/crypttab /mnt/etc/crypttab

  mkdir -p /mnt/etc
  info "Embedding key files in initrd"
  echo 'FILES=(/etc/cryptkey.d/* )' >>/mnt/etc/mkinitcpio.conf
}

set_root_passwd() {
  local root_passwd="$1"

  section "Setting initial root password"
  in_chroot "chpasswd <<< 'root:$root_passwd'"
}

enable_services() {
  local boot_pool="$1"
  local encrypt="$2"

  section "Enabling services"

  local enable_services=(
    "dhcpcd@${NETIF}.service"
    sshd.service
    zfs-import-scan.service
    zfs-import.target
    zfs-mount
    zfs-zed
    zfs.target
  )
  local service

  if [[ -n "$encrypt" ]]; then
    local base_path="$3"
    local unit=zfs-import-bpool-mapper.service
    mkdir -p /mnt/etc/systemd/system
    info "Installing systemd unit '$unit'"
    cp -v "$base_path/lib/$unit" "/mnt/etc/systemd/system/$unit"
    enable_services+=("$unit")
  fi

  if is_in_vmware; then
    enable_services+=(vmtoolsd.service)
  fi

  for service in "${enable_services[@]}"; do
    info "Enabling '$service' service"
    systemctl enable "$service" --root /mnt
  done
}

install_grub() {
  local disk_dev="$1"
  local inst_id="$2"
  local swap_dev="$3"
  local encrypt="$4"
  local tmp_swap_key="$5"
  local swap_mapper_name="$6"
  local hibernate="$7"

  section "Configuring and installing GRUB"

  info "Adding zfs_import_dir entry"
  local import
  import="zfs_import_dir=$(dirname "$disk_dev")"

  sed -i \
    -e "s,^\\(GRUB_CMDLINE_LINUX\\)=\"\\(.*\\)\"$,\\1=\"\\2 $import\"," \
    /mnt/etc/default/grub

  if [[ -n "$encrypt" ]]; then
    info "Enabling cryptdisk support"
    echo "GRUB_ENABLE_CRYPTODISK=y" >>/mnt/etc/default/grub
  fi

  if [[ -n "$swap_dev" && -n "$hibernate" ]]; then
    if [[ -n "$encrypt" ]]; then
      info "Adding cryptdevice entry"
      local partuuid
      partuuid="$(blkid -o export "$swap_dev" | grep ^PARTUUID)"
      local cryptdevice="cryptdevice=$partuuid:$swap_mapper_name:allow-discards"

      sed -i \
        -e "s,^\\(GRUB_CMDLINE_LINUX\\)=\"\\(.*\\)\"$,\\1=\"\\2 $cryptdevice\"," \
        /mnt/etc/default/grub

      info "Adding cryptkey entry"
      local cryptkey
      cryptkey="cryptkey=rootfs:/etc/cryptkey.d/$(basename "$tmp_swap_key")"

      sed -i \
        -e "s,^\\(GRUB_CMDLINE_LINUX\\)=\"\\(.*\\)\"$,\\1=\"\\2 $cryptkey\"," \
        /mnt/etc/default/grub
    fi

    local resume
    if [[ -n "$encrypt" ]]; then
      info "Adding resume entry"
      resume="resume=/dev/mapper/$swap_mapper_name"
    else
      info "Adding resume entry"
      resume="resume=$swap_dev"
    fi

    sed -i \
      -e "s,^\\(GRUB_CMDLINE_LINUX\\)=\"\\(.*\\)\"$,\\1=\"\\2 $resume\"," \
      /mnt/etc/default/grub
  fi

  info "Creating GRUB boot directories"
  mkdir -pv "/mnt/boot/efi/EFI/$inst_id"
  mkdir -pv "/mnt/boot/grub"

  info "Fixing pool name missing bug when generating grub.cfg"
  # See: https://wiki.archlinux.org/title/Install_Arch_Linux_on_ZFS
  local val
  val="zdb -l \${GRUB_DEVICE} \| grep -E '[[:blank:]]name' \| cut -d\\\' -f 2"
  sed -i -e "s|rpool=.*|rpool=\`$val\`|" /mnt/etc/grub.d/10_linux

  info "Installing GRUB (legacy)"
  in_chroot <<-EOF
	ZPOOL_VDEV_NAME_PATH=1 grub-install \
	  --boot-directory /boot/efi/EFI/$inst_id \
	  --target=i386-pc $disk_dev
	EOF

  info "Installing GRUB (EFI)"
  local label
  label="$inst_id-$(basename "$disk_dev")"
  in_chroot <<-EOF
	ZPOOL_VDEV_NAME_PATH=1 grub-install \
	  --boot-directory /boot/efi/EFI/$inst_id \
	  --efi-directory=/boot/efi/
	ZPOOL_VDEV_NAME_PATH=1 grub-install \
	  --boot-directory /boot/efi/EFI/$inst_id \
	  --efi-directory=/boot/efi/ \
	  --removable
	efibootmgr \
	  --create \
	  --gpt \
	  --part 1 \
	  --loader '\\EFI\\$inst_id\\grubx64.efi' \
	  --label $label \
	  --disk $disk_dev
	EOF

  info "Regenerate grub.cfg"
  in_chroot <<-EOF
	ZPOOL_VDEV_NAME_PATH=1 grub-mkconfig \
	  -o /boot/efi/EFI/$inst_id/grub/grub.cfg
	EOF
  cp -vp "/mnt/boot/efi/EFI/$inst_id/grub/grub.cfg" "/mnt/boot/grub/grub.cfg"

  if is_in_dell_xps_13; then
    info "Creating vconsole.conf for larger console font"
    echo "FONT=ter-132n" >/mnt/etc/vconsole.conf
  fi
}

configure_mkinitcpio() {
  local swap="$1"
  local encrypt="$2"
  local hibernate="$3"

  section "Configuring mkinitcpio"

  info "Modifying HOOKS in mkinitcpio.conf"
  local hooks
  hooks=(base udev keyboard autodetect modconf block consolefont)
  if [[ -n "$swap" ]]; then
    if [[ -n "$encrypt" ]]; then
      # To decrypt swap on boot and after resuming from hibernate
      hooks+=(encrypt)
    fi
    if [[ -n "$hibernate" ]]; then
      # Resuming from hibernate
      hooks+=(resume)
    fi
  fi
  hooks+=(zfs filesystems shutdown)
  sed -i "s,^HOOKS=.*,HOOKS=\"${hooks[*]}\",g" /mnt/etc/mkinitcpio.conf

  info "Update initial ramdisk (initrd) with ZFS support"
  in_chroot "mkinitcpio -P"
}

set_timezone() {
  local tz="$1"

  # * https://wiki.archlinux.org/index.php/Time
  # * https://wiki.archlinux.org/index.php/Systemd-timesyncd
  section "Setting up timezone to $tz"
  in_chroot "timedatectl set-timezone '$tz'"
}

setup_clock() {
  section "Setting up clock"

  # If hardware clock is set to local time, like in VMware Fusion
  #
  # * http://www.linuxfromscratch.org/lfs/view/stable-systemd/chapter07/clock.html
  if is_in_vmware; then
    # TODO fn: this doesn't appear to get set--is it needed?
    info "Setting time adjustment due to local time in hardware clock"
    in_chroot "timedatectl set-local-rtc 1"

    info "Enabling timesync"
    in_chroot "vmware-toolbox-cmd timesync enable"

    info "Creating hwclock-resume service unit to update clock after sleep"
    cat <<-'EOF' >/mnt/etc/systemd/system/hwclock-resume.service
	[Unit]
	Description=Update hardware clock after resuming from sleep
	After=suspend.target

	[Service]
	Type=oneshot
	ExecStart=/usr/bin/hwclock --hctosys --utc

	[Install]
	WantedBy=suspend.target
	EOF

    info "Enabling hwclock-resume service"
    in_chroot "systemctl enable hwclock-resume.service"
  else
    info "Enabling ntp"
    in_chroot "timedatectl set-ntp true"
  fi
}

generate_locales() {
  local locales=(en_CA.UTF-8 en_US.UTF-8 en_US)
  local default_locale="en_US.UTF-8"

  section "Generating locales"

  for l in "${locales[@]}"; do
    # shellcheck disable=SC1117
    sed -i "s|^#\(${l}\)|\1|" /mnt/etc/locale.gen
  done
  unset l
  info "Generating locales for ${locales[*]}"
  in_chroot "locale-gen"
  info "Setting default locale to $default_locale"
  echo "LANG=$default_locale" >/mnt/etc/locale.conf
}

find_fastest_mirrors() {
  section "Calculating fastest mirrors"

  # * https://ashu.io/blog/arch-zfs-enc/#set-mirrors
  reflector \
    --latest 20 \
    --protocol https \
    --sort rate \
    --save /mnt/etc/pacman.d/mirrorlist
  in_chroot "pacman -Syyu --noconfirm"
}

generate_hostid() {
  section "Generating /etc/hostid"
  zgenhostid -f -o /mnt/etc/hostid
}

copy_create_user_script() {
  local base_path="$1"
  local version="$2"
  local base_dataset="$3"

  section "Installing /root/bin/create-user script"

  local target="/mnt/root/bin/create-user"

  info "Preparing 'create-user.sh' script for root user"
  mkdir -p "$(dirname "$target")"
  cp -p -v "$base_path/lib/create-user.tmpl.sh" "$target"
  {
    echo
    cat "$base_path/lib/common.sh"
    echo
    cat "$base_path/vendor/lib/libsh.full.sh"
    echo
    echo 'main "$@"'
  } >>"$target"
  sed -i \
    -e "s,@@version@@,${version},g" \
    -e "s,@@base_dataset@@,${base_dataset},g" \
    "$target"
  chmod 0755 "$target"
}

snapshot_datasets() {
  local boot_dataset="$1"
  local root_dataset="$2"

  section "Taking ZFS snapshots of clean installation, pre-boot"

  local snap="install-preboot"

  info "Taking snapshot of '$root_dataset@$snap'"
  zfs snapshot -r "$root_dataset@$snap"
  info "Taking snapshot of '$boot_dataset@$snap'"
  zfs snapshot -r "$boot_dataset@$snap"
}

create_install_be_unit() {
  section "Creating systemd unit to create post install boot environment"

  local script service unit
  script="/.create_install_be.sh"
  service="create-install-be.service"
  unit="/etc/systemd/system/$service"

  info "Creating $script"
  cat <<-EOF >>"/mnt$script"
	#!/bin/bash
	set -eux

	if bieaz list -H | cut -f1 | grep -q '^install$'; then
	  echo "boot environment already created, skipping..."
	else
	  bieaz create "install"
	  bieaz label "install" "post install/pre boot"
	fi

	systemctl disable "$service"
	rm -f "$unit" "$script"
	EOF
  chmod 755 "/mnt$script"

  info "Creating $unit"
  mkdir -pv "/mnt$(dirname "$unit")"
  cat <<-EOF >>"/mnt$unit"
	[Unit]
	Description=Create install boot environment

	[Service]
	Type=simple
	ExecStart=$script

	[Install]
	WantedBy=multi-user.target
	EOF

  info "Enabling $service"
  systemctl enable "$service" --root /mnt
}

finalize_pools() {
  local boot_pool="$1"
  local root_pool="$2"
  local inst_id="$3"
  local swap="$4"
  local swap_dev="$5"
  local encrypt="$6"
  local hibernate="$7"
  local boot_pool_mapper_name="$8"
  local swap_mapper_name="$9"

  section "Finalizing ZFS pools"

  info "Unmounting /mnt/boot/efi"
  umount /mnt/boot/efi

  if [[ -n "$swap" && -n "$encrypt" && -n "$hibernate" ]]; then
    info "Closing encrypted swap '$swap_mapper_name'"
    cryptsetup close "$swap_mapper_name"
  fi

  info "Unmounting ZFS datasets"
  zfs unmount -a
  zfs unmount "$boot_pool/$inst_id/BOOT/default"
  zfs unmount "$root_pool/$inst_id/ROOT/default"

  info "Exporting ZFS zpools"
  zpool export "$boot_pool"
  zpool export "$root_pool"

  if [[ -n "$encrypt" ]]; then
    info "Closing encrypted root '$boot_pool_mapper_name'"
    cryptsetup close "$boot_pool_mapper_name"
  fi
}

finish() {
  section "Finished"
  info "Arch Linux with ZFS installer complete, reboot into installed system."
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@" || exit 99
fi
